---
title: Herding cats with dplyr
---

------------

```{r loading, echo = FALSE}
cats <- read.csv("data/cats.csv")
```

# `dplyr`

Bracket subsetting is handy, but it can be cumbersome and difficult to read,
especially for complicated operations. Enter `dplyr`!

`dplyr` is a package for making data manipulation easier. (It does a lot more too, but this is what we'll focus on).

```{r, eval = FALSE}
install.packages("dplyr")
```
Again, you may be asked to choose a CRAN mirror; RStudio is a good choice.

Now unlike the `rmarkdown` package, we'll be using `dplyr` in the console. In order to do that, we need to _load_ the package into our environment so we can access functions from `dplyr`. We do this with the `library` command:

```{r, message = FALSE}
library("dplyr")
```

You only need to install a package once per computer, but you need to load it
every time you open a new R session and want to use that package.


## Subsetting Data

The first two `dplyr` commands we'll use help us to subset our data by rows and columns.

### `select`
The first command we'll use is `select`, which allows us to choose columns from our dataset. Let's use our `cats` dataset and select only the `coat` column; we did this previously with

```{r}
cats[, "coat"]
```

With dplyr, we don't need to enclose our column names in quotes

```{r}
select(cats, coat)
```

Notice how the output differs slightly; all the main `dplyr` verbs behave consistently in that their inputs and outputs are both `data.frame`s, rather than returning a simple vector as the bracket-indexing method did.

We can select more columns by giving `select` additional arguments, and our output `data.frame` will have columns according to the order of our arguments

```{r}
select(cats, coat, cat_id)
```

### `filter`
So where `select` allowed us to select _columns_, `filter` operated on _rows_. Say we want to see the all the cats with black coats; we saw earlier how to use that using bracket-indexing:

```{r}
cats[cats$coat == "black", ]
```

In dplyr, this looks like

```{r}
filter(cats, coat == "black")
```

Notice we don't have to use the `$` operator to tell `filter` where the `coat` column is; it's smart enough to assume we want the `coat` column from the `data.frame` we passed in.


## Pipes
Before we talk about chaining `dplyr` operations, we need to introduce a tool that simplifies this chaining. Enter the "magrittr pipe", or just "pipe", which looks like `%>%`. It comes from the `magrittr` package and is loaded when you load `dplyr` into you environment (e.g. `library(dplyr)`).

The pipe is a binary operator (like `+` or `*`) which takes the ouput of a command and "pipes" it into another one. It can be used with most functions (it's not specific to `dplyr` functions). As an example, recall we can round a number like this

```{r}
round(1.23456789, 3)
```

We can use a pipe operator to acheive the same thing

```{r}
1.23456789 %>% round(3)
```

The pipe takes care of making sure the output of the expression on the left-hand-side (a simple numeric, in this case) is inserted as the first argument of the expressing on the right-hand-side. We can also pipe into other argument positions by using a period as a placeholder

```{r}
3 %>% round(1.23456789, .)
```

These are contrived examples, and I don't suggest using pipes for simple operations like rounding. The pipes really become useful when chaining together multiple operations in sequence, as we'll do with our `dplyr` functions.


## Combining Select & Filter
Remember how we used `filter` to select only the black cats? What if we only want to see the ID's of those cats, rather than all the info about them? We've already seen we can use `select` to pick out certain columns. We can use that to select the `cat_id` column from our `filter`ed dataset like so

```{r}
select(filter(cats, coat == "black"), cat_id)
```

That might not look too bad now, but what if we wanted to do another operation on that output? We'd add another layer of nesting, and having to read that line from the inside-out can quickly become annoying. We can use the pipe operator to clean that up

```{r}
filter(cats, coat == "black") %>% select(cat_id)
```

We could even add another pipe to feed `cats` into `filter`; it isn't necessary, but it makes it even easier to see what we're operating on in this chain of commands. We'll combine this with some line breaks to really make this easy to read:

```{r}
cats %>%
  filter(coat == "black") %>%
  select(cat_id)
```


## More `dplyr` Verbs
The two dplyr "verbs" we've used so far, `select` and `filter`, are useful, but only allow us to subset out dataset; to look at some smaller piece of it. The next verbs will allow us to gain new insight from the data by doing computations on it.

### `mutate`

First, the `mutate` function. `mutate` allows us to create a new variable in a `data.frame` from an expression. Say we want to make a new weight column that rounds the original weights of these cats to whole numbers; `mutate` allows us to do this

```{r}
cats %>% mutate(rounded_weight = round(weight))
```

Notice the output here had all the same columns we started with, plus this new column tacked onto the end. We could have also replaced a column with these new values by replacing `rounded_weight` with a pre-existing column name in our `mutate` call.

### `summarize`

While `mutate` creates new columns, it's often useful to summarize multiple rows into a single value. Say we want to find the mean weight of all these cats; enter `summarize`! Like `mutate`, the arguments to summarize (after the `data.frame` we want to operate on) are expressions. We can combine `summarize` with the `mean` function to get a mean weight for our collection of cats like so:

```{r}
cats %>% summarize(mean_weight = mean(weight))
```

Notice how we have only a single value returned, but it's still in a `data.frame` format. This is subtle, but important; all these basic `dplyr` verbs take in `data.frame`s and also return `data.frame`s. This consistency helps make long chains of `dplyr` operations possible.


### `group_by`

A very common data analysis task is to do operations like we did above, but to do them on a group-by-group basis. To do this with `dplyr`, we'll use the `group_by` function.

Let's look at the mean weights of our cats, grouping up by coat. This will give us the mean weight of the black cats, mean weight of the calico cats, etc. We can do this by inserting a `group_by` function into our earlier expression for computing mean weight:

```{r}
cats %>%
  group_by(coat) %>%
  summarize(mean_weight = mean(weight))
```

Ta-da!

We can also use `mutate` on a per-group basis. Let's make a new column which centers our weights around zero; this can be done by subtracting the group's mean weight from each cat's weight:

```{r}
cats %>%
  group_by(coat) %>%
  mutate(centered_weight = weight - mean(weight))
```

# Going further

This is an introductory look at `dplyr`, just enough to make you dangerous. As you continue your R journey I suggest looking into the other awesome things you can do with this package!


